---
title: "Programmieren und Datenbanken - Programmablauf"
author: "Joern Ploennigs"
format: revealjs
---

## Rekursion - Beispiel: Tree Traversal

::: {.columns}
::: {.column width="50%"}
*Baum:* Datenstruktur, in der jedes Element auf weitere Unterelemente verweisen kann.

Nun wollen wir eine Funktion auf jedes Element im Baum anwenden.

*Simpelste Repräsentation eines Baumes:*
- Ein Tupel mit einem Wert und einer Liste
- Diese Liste enthält Tupel mit jeweils einem Wert und einer Liste (Rekursive Datenstruktur!)
:::

::: {.column width="50%"}
```python
baum = (12, [
    (6,[
        (3,[]),
        (9,[])
    ]),
    (18,[
        (15,[]),
        (21,[])
    ])
])
```

```
       12
      /  \
     6    18
    / \   / \
   3   9 15  21
```
:::
:::



## Rekursion - Beispiel: Tree Traversal

Traversals sind Funktionen welche den Baum durchlaufen, z. B. um Elemente zu suchen.

```python
def traverse(tree):
    wert = tree[0]  # der aktuelle Wert
    print(wert)     # gebe den aktuellen Wert aus
    if tree[1]:     # wenn Kinder definiert sind
        for child in tree[1]:  # iteriere durch alle Kinder
            traverse(child)    # und rufe die Funktion rekursiv auf

traverse(baum)
```

*Ausgabe:* 12, 6, 3, 9, 18, 15, 21



## Informatik-Exkurs: Sortieren

- Speziell das Sortieren von Listen, unabhängig vom Datentyp
- Eine der Standard-Anwendungen für Schleifen und Rekursion
- Die Lösung im Programmieralltag: `sorted()`
- Aber: Gutes Beispiel für strukturiertes Informatik-Problem



## Sortieren - Algorithmus 1: Bubble Sort

- Jedes Element der Liste wird durchlaufen und mit dem nächsten Element verglichen.
- Ist das zweite Element kleiner als das erste wird die Position getauscht.
- Die Liste wird immer wieder durchlaufen bis dieser Fall nicht mehr auftritt.

```python
def bubbleSort(numbers):
    for i in range(len(numbers)-1):
        for j in range(0, len(numbers)-i-1):
            if numbers[j] > numbers[j + 1]:
                numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j]
```



## Sortieren - Algorithmus 2: Quick Sort

Das Grundprinzip ist das Aufteilen der Liste:

1. Das erste Element der Liste als „Pivot"-Element abspeichern.
2. Dann wird die Liste durchlaufen und jedes Element mit dem Pivot verglichen.
3. Einsortiert in eine von drei Listen: Kleiner, Gleich und Größer.
4. Dann wird Quick Sort rekursiv auf die Listen Kleiner und Größer ausgeführt.
5. Am Ende werden alle Listen rekursiv wieder zusammengeführt.



## Informatik-Exkurs: Suchen

- Speziell das Suchen auf sortierten Listen und Bäumen
- Meist kennt man die Anzahl an Elementen, weiß also genau wo z. B. die Mitte ist.
- Spätere Vorlesungen: In echten Anwendungen haben Datensätze oft mehr als nur einen Wert (Tabellen anstatt Listen), hier arbeitet man meist mit Indexierung.



## Suchen - Suche in Listen

Die einfachste Methode: *lineare Suche*

```python
def contains(list, x):
    for l in list:
        if(l == x):
            return True
    return False
```



## Suchen - Suche in Listen

Das optimale Verfahren: *Binäre Suche*

- Deutlich komplexerer Code
- *Idee:* Mittleres Element der Liste finden, dann mit dem gesuchten Wert vergleichen
- Wert kleiner: Selbes Verfahren für die erste Hälfte der Liste
- Wert größer: Selbes Verfahren für die zweite Hälfte der Liste
- Implementation meistens über Rekursion



## Suchen - Suchen in Bäumen

Strategien um einen unsortierten Baum zu durchsuchen:

*Breitensuche:* Vom Ursprung beginnend jede „Ebene" des Baumes von links nach rechts durchlaufen.

*Tiefensuche:* Einem Pfad vom Ursprung bis zum Ende folgen, dann schrittweise rückwärts gehen bis sich weitere Pfade anbieten.



## Suchen - Suchen in Bäumen

In sortierten Bäumen (Suchbäumen) kann das Ergebnis extrem effizient gefunden werden, da nur ein Pfad durchlaufen werden muss.

*Wie sortiert man einen Baum?* Erstellen eines binären Suchbaums

*Beispiel:* 12 6 18 15 3 21 9



## Suchbaum - Aufbau Schritt für Schritt

::: {.columns}
::: {.column width="50%"}
*Ausgangsliste:* 12 6 18 15 3 21 9

*Schritt 1:* 12 als Wurzel setzen
```
12
```

*Schritt 2:* 6 < 12, links einfügen
```
   12
  /
 6
```
:::

::: {.column width="50%"}
*Schritt 3:* 18 > 12, rechts einfügen
```
   12
  /  \
 6    18
```

*Schritt 4:* 15 > 12, aber 15 < 18
```
   12
  /  \
 6    18
     /
    15
```
:::
:::



## Suchbaum - Fortsetzung

::: {.columns}
::: {.column width="50%"}
*Schritt 5:* 3 < 12 und 3 < 6
```
   12
  /  \
 6    18
/    /
3   15
```

*Schritt 6:* 21 > 12 und 21 > 18
```
   12
  /  \
 6    18
/    /  \
3   15   21
```
:::

::: {.column width="50%"}
*Schritt 7:* 9 < 12 aber 9 > 6
```
   12
  /  \
 6    18
/ \  /  \
3  9 15  21
```

*Fertiger Suchbaum!*
:::
:::



## Exkurs: Komplexität und effiziente Algorithmen

Die eigentliche Berechnungszeit ergibt sich erst durch die genauen Eingabedaten und den genutzten Prozessor.

Formal ist Effizienz stattdessen eher eine Anstiegskurve, welche eine relative Schätzung abgibt wie viel länger ein Algorithmus bei mehr Eingabedaten rechnen muss.

*Notation:* O(x), wobei x die Menge der nötigen Rechenschritte angibt.

Für Bäume und Listen hängt diese von der Anzahl an Elementen ab (Variable n).



## Komplexität - Vergleich der Algorithmen

::: {.columns}
::: {.column width="50%"}
*Suchverfahren:*
- Lineare Suche: O(n)
- Binäre Suche: O(log(n))
:::

::: {.column width="50%"}
*Sortierverfahren:*
- Bubble Sort: O(n²)
- Quick Sort: O(n*log(n))
:::
:::



## Fragen?

*Hörsaalfrage*

*Zeit für Diskussion und Fragen zu Sortier- und Suchalgorithmen*