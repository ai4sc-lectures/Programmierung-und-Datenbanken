---
title: "EINFÜHRUNG IN PROGRAMMIERUNG UND DATENBANKEN"
subtitle: "Objektorientierung und Softwareentwurf"
author: "joern ploennigs"
format: 
  revealjs:
    theme: default
    transition: slide
    background-transition: fade
---

## PROGRAMMIERUNG UND DATENBANKEN

::: {style="display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center;"}

::: {style="background: #e8f4fd; padding: 1rem; border-radius: 8px; min-width: 150px;"}
**Motivation Computer und Architekturen**
:::

::: {style="background: #e8f4fd; padding: 1rem; border-radius: 8px; min-width: 150px;"}
**Programmierung und Datentypen**
:::

::: {style="background: #e8f4fd; padding: 1rem; border-radius: 8px; min-width: 150px;"}
**Fehler und Debugging**
:::

::: {style="background: #ffd700; padding: 1rem; border-radius: 8px; min-width: 150px;"}
**Objektorientierung u. Softwareentwurf**
:::

::: {style="background: #e8f4fd; padding: 1rem; border-radius: 8px; min-width: 150px;"}
**Verzweigungen und Schleifen**
:::

::: {style="background: #e8f4fd; padding: 1rem; border-radius: 8px; min-width: 150px;"}
**Funktionen und Rekursion**
:::

:::

::: {style="text-align: center; margin-top: 2rem;"}
**grundlagen** ← → **modellierung**
:::

---

## OBJEKTORIENTIERUNG

![Midjourney: Objects in the rear mirror may appear closer than they are](images/objects_mirror.png)

*programmieren und datenbanken - objektorientierung*

---

## ZIELSETZUNG

- Lernen der Grundidee der Objektorientierung
- Ein grundsätzliches Verständnis der Programmierung mit Objekten
- Datentypen vs. Klassen
- Funktionen vs. Methoden
- Einführung in erweiterte Konzepte wie z. B. Vererbung

---

## OBJEKTORIENTIERTE PROGRAMMIERUNG

Objektorientierte Programmierung (OOP) ist ein Programmierparadigma das annimmt, dass ein Programm ausschließlich aus Objekten besteht, die miteinander kooperativ interagieren. 

Jedes Objekt verfügt über **Attribute** (Eigenschaften) und **Methoden**. 

- Die **Attribute** definieren dabei Werte über den Zustand eines Objektes
- Die **Methoden** definieren die möglichen Zustandsänderungen (Handlungen) eines Objektes


## WARUM OBJEKTE – DAS SYNTAKTISCHE PROBLEM

Objekte werden verwendet, um festzulegen wie Datenstrukturen die sich wiederholen gespeichert werden. Hierbei geht es darum, dass der Syntax der Datenstruktur eindeutig ist.

Wächst das Programm an, so wächst auch die Menge der Variablen und Datenstrukturen:
- … zur Speicherung von Daten
- … zur Kontrolle des Programmflusses  
- … zum Abspeichern von Zuständen
- … zum Verarbeiten von Ein- und Ausgaben

Dabei basieren die zugrundeliegenden Elemente meist auf sich wiederholenden Datenstrukturen.

```python
punkt_1 = (54.083336, 12.108811)
punkt_2 = [12.108811, 54.083336]
```

**Was ist der Syntax der Werte?**

---

## WARUM OBJEKTE – DAS SEMANTISCHE PROBLEM

Objekte werden auch verwendet, um die Semantik von Werten einer Datenstruktur eindeutig zu definieren.

Haben wir uns z. B. darauf geeinigt, dass wir ein Punkt syntaktisch durch ein Tupel repräsentieren, so ist die Bedeutung der Werte dennoch nicht bekannt.

```python
punkt_1 = (54.083336, 12.108811)
punkt_2 = (12.108811, 54.083336)
```

**Was ist die Semantik dieser Werte?**

---

## WARUM OBJEKTE - DAS VERHALTENSPROBLEM

Objekte werden zudem verwendet, um die Funktionen zur Verarbeitung der Datenstrukturen direkt mit dieser zu bündeln, so dass die Datenstruktur nur jene Funktionen anbietet, welche auch sinnvoll anwendbar sind.

```python
def distanz(a, b):
    return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)

punkt_1 = (54.083336, 12.108811)
punkt_2 = (12.108811, 54.083336)
distanz(punkt_1,punkt_2)

linie_1 = [(54.08, 12.11), (54.10, 12.11)]
linie_2 = [(12.11, 54.08), (12.20, 54.10)]
distanz(linie_1, linie_2)  # Falsch!
```

**Können die Daten mit der Funktion verarbeitet werden?**

---

## GRUNDLAGEN DER OBJEKTORIENTIERUNG

Anstatt unübersichtlich viele verstreute Datenstrukturen und Funktionen zu benutzen, gruppieren wir diese in **Objekte**.

Die Struktur dieser Objekte wird in Form von **Klassen** definiert, welche eine Art Bauplan darstellt.

Eine Klasse definiert:
- welche **Attribute** (Variablen / Eigenschaften) ein Objekt dieser Klasse besitzt
- und welche **Methoden** (Funktionen) ein Objekt der Klasse bereit stellt

Diese werden zusammen in einer komplexen Datenstruktur gespeichert. Jedes Objekt stellt somit einen zusammengesetzten (komplexen) Datentypen dar.

---

## KLASSEN UND INSTANZEN

::: {style="display: flex; align-items: center; gap: 3rem;"}

::: {style="flex: 1;"}
Objekte selbst sind immer **Instanzen** einer Klasse (die Klasse ist ja nur ein Bauplan). 

Eine Klasse kann beliebig viele Instanzen haben oder gar keine. 

Alle Instanzen sind gleich aufgebaut, besitzen aber nicht unbedingt die gleichen Werte in den Attributen.
:::

::: {style="flex: 0 0 300px; text-align: center;"}
```
    Klasse
      ↓
┌─────────────┐
│   Instanz 1 │
└─────────────┘
       ...
┌─────────────┐
│   Instanz n │
└─────────────┘
```
:::

:::

---

## KLASSEN UND INSTANZEN - BEISPIEL

::: {style="display: flex; align-items: center; gap: 3rem;"}

::: {style="flex: 1;"}
Objekte selbst sind immer **Instanzen** einer Klasse (die Klasse ist ja nur ein Bauplan). 

Eine Klasse kann beliebig viele Instanzen haben oder gar keine. 

Alle Instanzen sind gleich aufgebaut, besitzen aber nicht unbedingt die gleichen Werte in den Attributen.
:::

::: {style="flex: 0 0 300px; text-align: center;"}
```
     Punkt
       ↓
┌─────────────┐
│   punkt_1   │
└─────────────┘
       ...
┌─────────────┐
│   punkt_n   │
└─────────────┘
```
:::

:::

---

## OBJEKTORIENTIERUNG IN PYTHON

- Python ist von Grund auf objektorientiert – ein Fakt den wir bisher ignoriert haben
- Alle Datentypen in Python sind Objekte (deshalb haben sie ja auch eigene Methoden)
- Selbst definierte Klassen sind immer ein zusammengesetzter (komplexer) Datentyp

Die Bestandteile eines Datentyp-Objektes sind:
- **Wert**
- **Typ**
- **Identität** (ID-Nummer)

Typ und Identität sind immer unveränderlich. Variablen sind Referenzen auf Objekt-Instanzen.

---

## KLASSEN DEFINIEREN

Der erste Schritt zu einem Objekt ist das Definieren einer neuen Klasse für den Typ des Objektes. Dies geschieht über das `class`-Kennwort:

```python
class Klassenname:
    # Klassendefinition
```

---

## KONSTRUKTOREN MIT DER INIT-METHODE

Der Konstruktor `__init__()` ist eine spezielle Methode, die festlegt wie eine neue Instanz der Klasse erzeugt wird.

```python
class Punkt:
    # Konstruktor
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

- `self` beschreibt eine Selbst-Referenz auf die neue Instanz der Klasse
- Auf die Attribute einer Instanz kann durch den Punkt-Syntax zugegriffen werden
- `self.x` ist somit eine Referenz auf das Attribut x der Instanz
- `self.x = x` bedeutet dass wir den Wert der Variablen x dem neuen Instanzattribut x zuweisen
- Da `__init__` eine Funktion ist, kann man auch Defaults definieren

---

## INSTANZEN ERZEUGEN

Instanzen der Klasse werden erzeugt indem der Klassenname wie ein Funktionsname benutzt wird.

Um Instanzen zu erstellen wird der Klassenname wie ein Funktionsname benutzt (dies ruft den Konstruktor impliziert auf). Hierbei wird der `self`-Parameter nicht mit angegeben.

```python
punkt_1 = Punkt(54.083336, 12.108811)
punkt_2 = Punkt(12.108811, 54.083336)
```

---

## ATTRIBUTE AUF INSTANZEBENE

- Instanzattribute können in jeder Instanz unterschiedlich sein
- Ändert eine Instanz das Attribut, so wirkt sich die Änderung nicht auf andere Instanzen aus (Isolierung)
- Sie werden in dem Konstruktor `__init__` definiert

```python
class Punkt:
    # Konstruktor
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

---

## ATTRIBUTE AUF KLASSENEBENE

- Klassenattribute sind Attribute welche für alle Instanzen einer Klasse den gleichen Wert haben
- Sie werden unter dem `class`-Kennwort wie eine Variable definiert
- **Wichtig!** Sie gelten für alle Instanzen, wenn also eine Instanz den Wert ändert, so ändert er sich in allen anderen Instanzen

```python
class Punkt:
    # Attribut aller Instanzen
    einheit = "m"
```

---

## METHODEN

- Methoden werden wie Funktionen mit dem Schlüsselwort `def` definiert, auf der gleichen Ebene eingerückt wie die Klasse
- Diese Methoden sind dann in allen Instanzen verfügbar
- Methoden besitzen immer `self` als ersten Parameter (Referenz auf aktuelle Instanz)
- Dadurch kann man dann auf die Attribute oder andere Methoden zugreifen
- Man kann Parametern der Methoden auch Defaults zuweisen

```python
class Punkt:
    # Methode
    def distanz(self, punkt_2):
        return math.sqrt((self.x - punkt_2.x)**2 + (self.y - punkt_2.y)**2)
```

---

## METHODEN AUFRUFEN

Klassenmethoden sind in allen Instanzen verfügbar. Sie werden durch den Punkt-Syntax aufgerufen:

```python
punkt_1.distanz()
```

Auf gleiche Weise kann auch auf Attribute zugegriffen werden:

```python
print(punkt_1.x, punkt_1.y)
```

und diese verändert werden:

```python
punkt_1.x = 20
```

---

## Hörsaalfrage: FRAGEN? {.center}

![Midjourney: A psychedelic DJ with a question mark for a head](images/dj_question.png)

*programmieren und datenbanken - objektorientierung*